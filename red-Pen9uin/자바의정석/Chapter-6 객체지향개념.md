# Chapter 6. 객체지향개념 I

![velog 표지용](Chapter-6 객체지향개념/velog 표지용.png)

<br>

> **목차**
> [1. 객체지향언어란?](#1-객체지향언어란)
> [2. 클래스와 객체](#2-클래스와-객체)
> [3. 변수와 메서드](#3-변수와-메서드)
> [4. 메서드 오버로딩](#4-메서드-오버로딩method-overloading)
> [5. 생성자](#5-생성자constructor)
> [6. 변수의 초기화](#6-변수의-초기화)

<br>

# 1. 객체지향언어란?
## 1.1 객체지향언어의 역사
- 과학, 군사적 모의실험(simulation)을 위해 컴퓨터를 이용한 가상세계를 구현하려는 노력으로부터 객체지향이론이 시작됨
- 1960년대 최초의 객체지향언어 Simula탄생
- 1980년대 절차방식의 프로그래밍의 한계를 객체지향방식으로 극복하려고 노력함.(C++, Smalltalk과 같은 보다 발전된 객체지향언어가 탄생)
- 1995년 말 Java탄생. 객체지향언어가 프로그래밍 언어의 주류가 됨.

<br>

## 1.2 객체지향언어의 특징
- **기존의 프로그래밍언어와 크게 다르지 않다.**
  - 기존의 프로그래밍 언어에 몇가지 규칙을 추가한 것일 뿐이다.
- **코드의 재사용성이 높다.**
  - 새로운 코드를 작성할 때 기존의 코드를 이용해서 쉽게 작성할 수 있다.
- **코드의 관리가 쉬워졌다.**
  - 코드간의 관계를 맺어줌으로써 보다 적은 노력으로 코드변경이 가능하다.
- **신뢰성이 높은 프로그램의 개발을 가능하게 한다.**
  - 제어자와 메서드를 이용해서 데이터를 보호하고, 코드의 중복을 제거하여 코드의 불일치로 인한 오류를 방지할 수 있다.

<br>

---

<br>


# 2. 클래스와 객체

## 2.1 클래스와 객체의 정의와 용도

> **객체란(Object)?**
> 
> 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것.
> 객체는 속성과 동작으로 구성되어 있다고 볼 수 있다.
> 자바에서는 이 속성과 동작을 각각 필드(field) 와 메소드(method)라 칭한다.
>
> *출처: [개발자를 꿈꾸는 프로그래머](https://jwprogramming.tistory.com/121)*

- `클래스`
  - 클래스의 정의: 객체를 정의해 놓은 것
  - 클래스의 용도: 객체를 생성하는데 사용

- `객체`
  - 객체의 정의: 실제로 존재하는 것. 사물 또는 개념.
  - 객체의 용도: 객체의 속성과 기능에 따라 다름.


| 클래스      | 객체   |
| ----------- | ------ |
| 제품 설계도 | 제품   |
| TV 설계도   | TV     |
| 붕어빵 기계 | 붕어빵 |

<br>

## 2.2 객체와 인스턴스
- 객체 ≒ 인스턴스
  - 객체(object)는 인스턴스(instance)를 포함하는 일반적인 의미

![image-20220113184851181](Chapter-6 객체지향개념/image-20220113184851181.png)

- 인스턴스화(instantiate, 인스턴스化)
  - 클래스로부터 인스턴스를 생성하는 것.

![image-20220113184955177](Chapter-6 객체지향개념/image-20220113184955177.png)

<br>

## 2.3 객체의 구성요소 – 속성과 기능
- 객체는 **속성**과 **기능**으로 이루어져 있다.
  - **<u>객체는 속성과 기능의 집합</u>**이며, 속성과 기능을 객체의 `멤버(member, 구성요소)`라고 한다.

- **속성은 변수**로, **기능은 메서드**로 정의한다.
  - 클래스를 정의할 때 객체의 속성은 변수로, 기능은 메서드로 정의한다.

> 속성(property) - 멤버 변수(member variable), 특성(attribute), 필드(filed), 상태(state)
>
> 기능(function) - 메서드(method), 함수(function), 행위(behavior)

![image-20220113185155524](Chapter-6 객체지향개념/image-20220113185155524.png)

<br>

## 2.4 인스턴스의 생성과 사용

> - 참조변수는 말 그대로 참조하기 위해 사용할 뿐, 실**제 데이터는 인스턴스에 저장된다.**
> - 참조변수는 **실제 데이터를 가지고 있는 인스턴스의 주소를 관리하기 위해 존재하는 변수**이다.
> - 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.
> - 각 인스턴스의 속성은 서로 다른 값을 유지할 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.

- 인스턴스의 생성방법

```java
// 객체를 다루기 위한 참조변수 선언
// 인스턴스가 할당되지 않은 참조변수로는 아무것도 할 수 없다
class_name val_name;
// 객체생성 후, 생성된 객체의 주소를 참조변수에 저장
val_name = new class_name();
```
```java
// 객체를 생성하고, 객체를 다루기 위한 참조변수를 선언해 그 주소를 저장한다
class_name val_name = new class_name();
```

- 인스턴스의 사용방법

```java
val_name.member1 = 10;
val_name.method1();
System.out.println(val_name.member1)
```

- 예시

```java
class Tv {
	String color; // 색깔
    boolean power; // 전원상태(on/off)
    int channel; // 채널
    void power() { power = !power; } // 전원on/off
    void channelUp( channel++;) // 채널 높이기
    void channelDown {channel--;} // 채널 낮추기
}

Tv t;
t = new Tv();
t.channel = 7;
t.channelDown();
System.out.println(t.channel);
```

- 참조변수와 인스턴스의 관계

```java
Tv t1 = new Tv();
Tv t2 = new Tv();
// t1이 가지고 있던 값을 t2에 저장한다
// t2가 참조하고 있던 인스턴스의 주소를 잃으므로 해당 인스턴스를 더이상 사용할 수 없게 된다
t2 = t1;
t1.channel = 7;
System.out.println(t1.channel);
System.out.println(t2.channel);
```

![image-20220113190738936](Chapter-6 객체지향개념/image-20220113190738936.png)

> - 많은 상황에서 매번 새로 객체를 할당하는 파이썬과 다르게, 자바는 변수가 직접 가지고있는 값이 바뀌기도 한다.

<br>

## 2.5 클래스의 또 다른 정의

### 1. 클래스 - 데이터와 함수의 결합

![image-20220113190949835](Chapter-6 객체지향개념/image-20220113190949835.png)

- 변수: 하나의 데이터를 저장할 수 있는 공간
- 배열: 같은 타입의 여러 데이터를 저장할 수 있는 공간
- 구조체: 타입에 관계없이 서로 관련된 데이터들을 저장할 수 있는 공간
- 클래스: 데이터와 함수의 결합(구조체+함수)

### 2. 클래스 - 사용자 정의 타입(User-defined type)

![image-20220113191223915](Chapter-6 객체지향개념/image-20220113191223915.png)



- 프로그래머가 서로 관련된 값을 묶어서 하나의 타입으로 직접 정의하는 것.

![image-20220113191403978](Chapter-6 객체지향개념/image-20220113191403978.png)

![image-20220113191518357](Chapter-6 객체지향개념/image-20220113191518357.png)

<br>

---

<br>

# 3. 변수와 메서드

## 3.1 선언위치에 따른 변수의 종류

- 변수의 선언위치가 변수의 종류와 범위(scope)를 결정한다.

| 변수의 종류  | 선언위치    | 생성시기                    |
| ------------ | ----------- | --------------------------- |
| 클래스변수   | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스변수 | 클래스 영역 | 인스턴스 생성시             |
| 지역변수     | 메서드 영역 | 변수 선언문 수행시          |

![image-20220113192456337](Chapter-6 객체지향개념/image-20220113192456337.png)

- `인스턴스변수(instance variable)`
  - 각 인스턴스의 <u>개별적인 저장공간</u>. <u>인스턴스마다 다른 값</u> 저장가능
  - 인스턴스 생성 후, `‘참조변수.인스턴스변수명’`으로 접근
  - 인스턴스를 생성할 때 생성되고, 참조변수가 없을 때 가비지컬렉터에 의해 자동제거됨

- `클래스변수(class variable)`
  - 같은 클래스의 <u>모든 인스턴스들이 공유하는 변수</u>
  - 인스턴스 생성없이 `‘클래스이름.클래스변수명’`으로 접근
  - 클래스가 로딩될 때 생성되고 프로그램이 종료될 때 소멸

- `지역변수(local variable)`
  - 메서드 내에 선언되며, <u>메서드의 종료와 함께 소멸</u>
  - 조건문, 반복문의 블럭`{}` 내에 선언된 지역변수는 블럭을 벗어나면 소멸

<br>

## 3.2 클래스변수와 인스턴스변수

- 인스턴스변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, **<u>클래스변수는 모든 인스턴스가 하나의 저장공간을 공유</u>**하므로 항상 공통된 값을 갖는다.

![image-20220113192809929](Chapter-6 객체지향개념/image-20220113192809929.png)

![image-20220113192910281](Chapter-6 객체지향개념/image-20220113192910281.png)

<br>

## 3.3 메서드(method)

- **메서드**란?
  - 작업을 수행하기 위한 명령문의 집합
  - 어떤 값을 입력받아서 처리하고 그 결과를 돌려준다.
  - 입력받는 값이 없을 수도 있고 결과를 돌려주지 않을 수도 있다.
- 메서드의 장점과 작성지침
  - 반복적으로 수행되는 여러 문장을 메서드로 작성한다.
  - 관련된 여러 문장을 메서드로 작성한다.
  - 반복적인 코드를 줄이고 코드의 관리가 용이하다.
- 메서드의 정의 방법: 클래스 영역에만 정의할 수 있음

![image-20220113193120227](Chapter-6 객체지향개념/image-20220113193120227.png)

<br>

## 3.4 `return`문

- 메서드가 정상적으로 종료되는 경우
  - 메서드의 블럭`{}`을 수행 도중 `return`문을 만났을 때
  - 메서드의 블럭`{}`의 끝에 도달했을 때

- `return`문
  - 현재 실행 중인 메서드를 종료하고 호출한 메서드로 되돌아간다.
  - 반환값이 있는 경우, 메서드에서 지정한 `return 타입`과 일치해야 한다.

```java
//반환값이 없는 경우
return;
//반환값이 있는 경우, 반환값을 지정해야 한다
return 반환값;
```

- 주의사항
  - 반환값이 있는 메서드는 **<u>모든 경우에 `return`문이 있어야 한다.</u>**
  - `return`문의 개수는 **<u>최소화</u>**하는 것이 좋다.

<br>

## 3.5 메서드 호출

```java
참조변수.메서드_이름(); // 메서드에 선언된 매개변수가 없는 경우
참조변수.메서드_이름(값1, 값2, ... ); // 메서드에 선언된 매개변수가 있는 경우
```

<br>

## 3.6 JVM의 메모리구조

![image-20220113195947457](Chapter-6 객체지향개념/image-20220113195947457.png)

- 메서드 영역(`Method Area`)

  - 클래스 정보와 클래스변수가 저장되는 곳

- 호출스택(`Call Stack`)

  - 메서드의 작업공간
  - 메서드가 호출되면 메서드 수행에 필요한 메모리공간을 할당
  - 메서드가 종료되면 사용하던 메모리를 반환
  > 호출스택의 제일 위에 있는 메서드가 **현재 실행중인 메서드**
  > 아래에 있는 메서드가 **바로 위의 메서드를 호출한 메서드**
  > ![image-20220113200228532](Chapter-6 객체지향개념/image-20220113200228532.png)

- 힙(`Heap`)

  - 인스턴스가 생성되는 공간
  - `new` 연산자에 의해서 생성되는 배열과 객체는 모두 여기에 생성

<br>

## 3.7 기본형 매개변수와 참조형 매개변수

> 자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.
> 매개변수의 타입이 기본형(primitive type)일 때는 기본형 값이 복사되겠지만, 참조형(reference type)이면 인스턴스의 주소가 복사된다.

- 기본형 매개변수: 변수의 값을 **<u>읽기만</u>** 할 수 있다. `(read only)`
- 참조형 매개변수: 변수의 값을 **<u>읽고 변경</u>**할 수 있다. `(read & write)`

<br>

## 3.8 재귀호출

- 재귀호출이란?
  - 메서드 내에서 자기자신을 반복적으로 호출하는 것
  - 재귀호출은 반복문으로 바꿀 수 있으며 반복문보다 성능이 나쁘다.
  - 이해하기 쉽고 간결한 코드를 작성할 수 있다.
- 재귀호출의 예시
  - 팩토리얼, 제곱, 트리운행, 폴더목록표시 등

> *재귀 호출의 단점:*
>
> 1. ***시간복잡도가** 반복문에 비해 **계산이 어렵다**.*
> 2. ***반복문보다 큰 오버헤드를 가짐***
>    *(반복문보다 메모리 사용량 많고 수행 시간이 더 길어질 수 있다)*
> 3. *함수 호출을 많이 하기에 **StackOverFlow 가능성***
> 4. ***종결조건이 A 측면, B 측면에서도 확실해야 한다. 그렇지 않으면 무한 반복이 일어난다.***
> 5. ***무한반복이 일어나는 경우 CPU 크래쉬를 초래한다.*** 
>    *( 반복문의 경우 메모리가 부족할 때가 되면 알아서 멈춘다)*

<br>

## 3.9 클래스 메서드와 인스턴스 메서드

- 인스턴스메서드
  - 인스턴스 생성 후, `참조변수.메서드이름()`으로 호출
  - 인스턴스변수나 인스턴스메서드와 관련된 작업을 하는 메서드
  - 메서드 내에서 인스턴스변수 사용가능

- 클래스메서드(`static` 메서드)
  - 객체생성없이 `클래스이름.메서드이름()`으로 호출
  - **<u>인스턴스변수나 인스턴스메서드와 관련없는 작업을 하는 메서드</u>**
  - **<u>메서드 내에서 인스턴스변수 사용불가</u>**
  - 메서드 내에서 인스턴스변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.

```java
class MyMath2 {
    long a, b;
    
    long add() { // 인스턴스메서드
    	return a + b;
    }
    
    static long add(long a, long b) { // 클래스메서드(static메서드)
    	return a + b;
    }
}
```

<br>

## 3.10 멤버간의 참조와 호출

- 같은 클래스의 멤버간에는 객체생성이나 참조변수 없이 참조할 수 있다.
- `static`멤버들은 **<u>인스턴스멤버(변수, 메서드 모두)들을 참조할 수 없다</u>**.
  - 클래스변수의 호출/참조는 가능

```java
Class TestClass {
    void instanceMethod() {}		//인스턴스 메서드
    static void staticMethod() {}	//스태틱 메서드
    
    void instanceMethod2() {		//인스턴스 메서드
        instanceMethod();			//다른 인스턴스매서드 호출(OK)
        staticMethod();				//다른 스태틱매서드 호출(OK)
    }
    static void staticMethod2() {	//스태틱 메서드
        instanceMethod();			//Error (다른 인스턴스멤버 참조 불가)
        staticMethod();				//다른 스태틱매서드 호출(OK)
    }
}
```



<br>

---

<br>

# 4. 메서드 오버로딩(Method overloading)

## 4.1 메서드 오버로딩(method overloading)이란?

> overload - vt. 과적하다. 부담을 많이 지우다.

- 하나의 클래스에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩, 간단히 오버로딩이라고 한다.
- **<u>매개변수는 다르지만 같은 의미의 기능을 수행할 수 있도록 한다.</u>**

<br>

## 4.2 오버로딩의 조건

- 메서드의 **이름**이 같아야 한다.
- **매개변수의 개수 또는 타입이 달라야 한다**.
  - 매개변수의 이름이 다른 것은 오버로딩이 아니다.

- 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않는다.
  - 리턴타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.

<br>

## 4.3 오버로딩의 예

- `System.out.println()`메서드
  - 다양하게 오버로딩된 메서드를 제공함으로써 모든 변수를 출력할 수 있도록 설계

![image-20220113204727454](Chapter-6 객체지향개념/image-20220113204727454.png)



<br>

---

<br>

# 5. 생성자(Constructor)

## 5.1 생성자(constructor)란?

- 인스턴스가 생성될 때마다 호출되는 **<u>인스턴스 초기화 메서드</u>**
- 인스턴스 변수의 초기화 또는 인스턴스 생성시 수행할 작업에 사용
- 몇가지 조건을 제외하고는 **메서드와 같다.**
- 모든 클래스에는 **반드시 하나 이상의 생성자가 있어야 한다.**
  - _인스턴스 초기화 – 인스턴스 변수에 적절한 값을 저장하는 것._

![image-20220113212748371](Chapter-6 객체지향개념/image-20220113212748371.png)

<br>

## 5.2 생성자의 조건

- 생성자의 이름은 **클래스의 이름과 같아야** 한다.
- 생성자는 **리턴값이 없다.**
  - 하지만 **void를 쓰지 않는다.**

```java
클래스이름(타입 변수명, 타입 변수명, ... ) {
    // 인스턴스 생성시 수행될 코드
    // 주로 인스턴스 변수의 초기화 코드를 적는다.
}
```



**<br>**

## 5.3 기본 생성자(default constructor)

> _모든 클래스에는 반드시 하나 이상의 생성자가 있어야 한다._

- 기본 생성자란?
  - 매개변수가 없는 생성자
    - `클래스이름() { }`
  - 클래스에 생성자가 하나도 없으면 컴파일러가 기본 생성자를 추가한다.

```java
Card() { } // 컴파일러에 의해 추가된 Card클래스의 기본 생성자. 내용이 없다.
```



<br>

## 5.4 매개변수가 있는 생성자

![image-20220113213420037](Chapter-6 객체지향개념/image-20220113213420037.png)

> Overloading을 이용해 다수의 생성자를 만들어주자.

<br>

## 5.5 생성자에서 다른 생성자 호출하기 – `this()`

- `this()`
  - **<u>생성자</u>** (`this`와 다르다)
  - **<u>같은 클래스의 다른 생성자를 호출할 때</u>** 사용
  - 다른 생성자 호출은 **<u>생성자의 첫 문장에서만 가능</u>**
- 잘 활용하면 코드의 재사용성을 높일 수 있다.

```java
class Car{
	String color; // 인스턴스 변수
    String gearType;
    int door; 
    
    Car(){
        this("white", "auto", 4); // Car(String color, string gearType, int door)를 호출
    }
    
    Car(String color){
        this(color, "auto", 4);
    }
    
    Car(String color, String gearType, int door){
        this.color = color; 
        this.gearType = gearType;
        this.door = door;
    }
}
```



<br>

## 5.6 참조변수 `this`

- `this`
  - **<u>인스턴스 자신</u>**을 가리키는 **<u>참조변수</u>**
  - 인스턴스의 주소가 저장되어있음
  - 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재
- 인스턴스변수와 지역변수를 구별하기 위해 `this`를 사용한다.

```java
class Car {
    String color; // 인스턴스 변수
    String gearType;
    int door; 
    
    Car(String color, String gearType, int door){
        this.color = color; 
        this.gearType = gearType;
        this.door = door;
    }
}
```



<br>

## 5.7 생성자를 이용한 인스턴스의 복사

- **인스턴스간의 차이는 인스턴스변수의 값 뿐** 나머지는 동일하다.
- 생성자에서 **참조변수를 매개변수로 받아서 인스턴스변수들의 값을 복사**한다.
- 똑같은 속성값을 갖는 독립적인 인스턴스가 하나 더 만들어진다.

![image-20220113214151666](Chapter-6 객체지향개념/image-20220113214151666.png)

<br>

---

<br>

# 6. 변수의 초기화

## 6.1 변수의 초기화

- **변수를 선언하고 처음으로 값을 저장하는 것**
- 멤버변수(인스턴스변수,클래스변수)와 배열은 각 타입의 기본값으로 자동초기화되므로 초기화를 생략할 수 있다.
- **지역변수는 사용전에 꼭!!! 초기화를 해주어야한다.**
  - 같은 타입의 변수는 콤마`,`를 사용해서 함께 선언하거나 초기화할 수 있다.
  - 타입이 다른 변수는 함께 선언하거나 초기화할 수 없다.


<br>

## 6.2 멤버변수의 초기화

### 1. 명시적 초기화(explicit initialization)

```java
class Car {
	int door = 4;				//기본형(primitive type) 변수의 초기화
	Engine e = new Engine();	//참조형(reference type) 변수의 초기화
	//...
}
```



### 2. 생성자(constructor)

```java
Car() {
  System.out.println("Car 인스턴스가 생성되었습니다.");
  this.color = color;
  this.gearType = gearType;
}
```



### 3. 초기화 블럭(initialization block)

- 클래스 초기화 블럭 : `static {}`
- 인스턴스 초기화 블럭 : `{}`

<br>

## 6.3 초기화 블럭


### 클래스 초기화 블럭 : `static {}`

- **클래스변수의 복잡한 초기화**에 사용
- **클래스가 로딩될 때** 실행

### 인스턴스 초기화 블럭 : `{}`

- **생성자에서 공통적으로 수행되는 작업**에 사용
- 인스턴스가 생성될 때마다 **(생성자보다 먼저)** 실행된다.

```java
class Car {
    int door = 4;				//기본형(primitive type) 변수의 초기화
	Engine e = new Engine();	//참조형(reference type) 변수의 초기화
	String color; // 인스턴스 변수
    String gearType;
    
    Car() {
      System.out.println("Car 인스턴스가 생성되었습니다."); //공통 수행
      color = "White";
      gearType = "Auto";
    }

    Car(String color, String gearType) {
      System.out.println("Car 인스턴스가 생성되었습니다."); //공통 수행
      this.color = color;
      this.gearType = gearType;
    }
/*----------------------------------------------------------------*/
    // 이러한 코드가 이렇게 된다!

    { System.out.println("Car 인스턴스가 생성되었습니다."); } //인스턴스 블럭
    Car() {
      color = "White";
      gearType = "Auto";
    }

    Car(String color, String gearType) {
      this.color = color;
      this.gearType = gearType;
    }
}
```



<br>

## 6.4 멤버변수의 초기화 시기와 순서

- 초기화 시점
  - 클래스변수 초기화 시점: **<u>클래스가 처음 로딩될 때 단 한번</u>**
  - 인스턴스변수 초기화 시점: **<u>인스턴스가 생성될 때 마다</u>**
- 초기화 순서
  - 클래스 변수 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
  - 인스턴스 변수 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

```java
class InitTest {
    static int cv = 1;
    int iv = 1;
    
    static { cv = 2; }
    { iv = 2; }
    
    InitTest() {
        iv = 3;
    }
}

InitTest it = new InitTest();
```



![image-20220114161515787](Chapter-6 객체지향개념/image-20220114161515787.png)
