# Chapter 7. 객체지향개념 II

![velog 표지용](Chapter-7 객체지향개념/velog 표지용.png)

> **목차**
> [1. 상속](#1-상속inheritance)
> [2. 오버라이딩](#2-오버라이딩overriding)
> [3. package와 import](#3-package와-import)
> [4. 제어자](#4-제어자)
> [5. 다형성](#5-다형성polymorphism)
> [6. 추상클래스](#6-추상클래스abstract-class)
> [7. 인터페이스](#7-인터페이스interface)
> [8. 내부 클래스](#8-내부-클래스)
> [9. 익명 클래스](#9-익명클래스anonymous-class)

<br>

---

<br>

# 1. 상속(inheritance)

## 1.1 상속의 정의와 장점

- 상속이란?
  - **기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것**
  - 두 클래스를 Parent과 Child으로 관계를 맺어주는 것
  - Child은 Parent의 멤버를 상속받는다.
    - <u>생성자, 초기화블럭 제외</u>
  - Child의 멤버개수는 Parent보다 적을 수 없다.
    - <u>무조건 같거나 많다.</u>

```java
class ChildClass extends ParentClass {
	// ...
}
```

![image-20220114165814746](Chapter-7 객체지향개념/image-20220114165814746.png)

<br>

## 1.2 클래스간의 관계

- **상속관계(inheritance)**
  - **공통부분은 Parent에서 관리**하고 개별부분은 Child에서 관리한다.
  - Parent의 변경은 Child에 영향을 미치지만, **Child의 변경은 Parent에 아무런 영향을 미치지 않는다.**

![image-20220114165936698](Chapter-7 객체지향개념/image-20220114165936698.png)

- **포함관계(composite)**
  - 한 클래스의 멤버변수로 다른 클래스를 선언하는 것
  - 작은 단위의 클래스를 먼저 만들고, 이 들을 조합해서 하나의 커다란 클래스를 만든다.

![image-20220114170321960](Chapter-7 객체지향개념/image-20220114170321960.png)

<br>

## 1.3 클래스간의 관계결정하기 - 상속 vs. 포함

- **클래스끼리 가능한 한 많은 관계를 맺어주어 재사용성을 높이고 관리하게 쉽게 한다.**
- 관계를 결정할 때엔 `is-a`와 `has-a`를 가지고 문장을 만들어 볼 것.
  - `~은 ~이다(is-a)` =상속관계
  - `~은 ~을 가지고 있다(has-a)` =포함관계
> - 원(Circle)은 도형(Shape)이다.(`A Circle is a Shape.`) : 상속관계  
> - 원(Circle)은 점(Point)를 가지고 있다.(`A Circle has a Point.`) : 포함관계

<br>

## 1.4 단일 상속(single inheritance)

- **<u>Java는 단일 상속만을 허용한다.</u>**
  - C++은 다중상속 허용
- **<u>비중이 높은 클래스 하나만 상속관계로</u>**, 나머지는 포함관계로 구성할 것

<br>

## 1.5 `Object`클래스

- **<u>모든 클래스의 최고조상</u>**
- Parent가 없는 클래스는 자동적으로 `Object` 클래스를 상속받는다.
- 상속계층도의 최상위에는 `Object` 클래스가 위치한다.
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.
  - `toString(), equals(Object obj), hashCode(), ...`

<br>

---

<br>

# 2. 오버라이딩(overriding)

## 2.1 오버라이딩이란?

> _override - vt. ‘~위에 덮어쓰다(overwrite).’, ‘~에 우선하다.’_

- _**Parent클래스로부터 상속받은 메서드의 내용을 상속받는 Child클래스에 맞게 변경하는 것**_

```java
class Point {
    int x;
    int y;
    
    String getLocation() {
        return "x: "+ x +", y: "+ y;
    }
}

class Point3D extends Point {
    int z;
    String getLocation() {	//오버라이딩
        return "x: "+ x +", y: "+ y + ", z: " + z;
    }
}
```



<br>

## 2.2 오버라이딩의 조건

1. **선언부가 같아야** 한다.
   - 이름, 매개변수, 리턴타입
2. 접근제어자를 **좁은 범위로 변경할 수 없다.**
   - Parent의 메서드가 `protected`라면, **범위를 같거나 넓은 `protected`나 `public`으로만** 변경할 수 있다.
3. **Parent클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.**

![image-20220119112024198](Chapter-7 객체지향개념/image-20220119112024198.png)

<br>

## 2.3 오버로딩 vs. 오버라이딩

- **오버로딩(over loading)** - 기존에 없는 **새로운 메서드를 정의**하는 것(`new`)
- **오버라이딩(overriding)** -  상속받은 메서드의 **내용을 변경**하는 것(`change, modify`)

![image-20220119112729421](Chapter-7 객체지향개념/image-20220119112729421.png)

<br>

## 2.4 `super` - 참조변수

- 참조변수 `super`
- `this`
  - 인스턴스 자신을 가리키는 참조변수
  - 인스턴스의 주소가 저장되어잇음
  - 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재
- `super`
  - `this`와 **<u>같음</u>**
  - **<u>Parent의 멤버와 자신의 멤버를 구별</u>**하는 데 사용

![image-20220119112948952](Chapter-7 객체지향개념/image-20220119112948952.png)

```java
class Point {
    int x;
    int y;
    
    String getLocation() {
        return "x: "+ x +", y: "+ y;
    }
}

class Point3D extends Point {
    int z;
    String getLocation() {	//오버라이딩
        //return "x: "+ x +", y: "+ y + ", z: " + z;
        //parent의 메서드 호출
        return super.getLocation() + ", z: " + z;
    }
}
```



<br>

## 2.5 `super()` - Parent의 생성자

- Child클래스의 인스턴스를 생성하면, **Child의 멤버와 Parent의 멤버가 합쳐진 하나의 인스턴스**가 생성된다.
- Parent의 멤버들도 초기화되어야 하기 때문에 Child의 생성자의 첫 문장에서는 Parent의 생성자를 호출해야 한다.
  - Object클래스를 제외한 모든 클래스의 첫 줄에는 생성자(같은 클래스의 다른 생성자 또는 Parent의 생성자)를 호출해야 한다.
  - 그렇지 않으면 컴파일러가 자동적으로 `super();`를 생성자의 첫 줄에 삽입한다.

![image-20220119113512186](Chapter-7 객체지향개념/image-20220119113512186.png)

<br>

---

<br>

# 3. `package`와 `import`

## 3.1 패키지(`package`)

- 서로 관련된 클래스와 인터페이스의 묶음
- 클래스가 물리적으로 클래스파일(`*.class`)인 것처럼, 패키지는 물리적으로 `폴더`이다.
  - 하위 패키지는 하위 폴더.

- 패키지는 서브패키지를 가질 수 있으며, '`.`'으로 구분한다.
- 클래스의 실제 이름(full name)은 <u>패키지명이 포함된 것</u>이다.
  - `String`클래스의 full name은 `java.lang.String`
- `rt.jar`는 Java API의 기본 클래스들을 압축한 파일
  - `rt` = runtime. 자바 프로그램을 실행할 때 필요한 클래스를 묶어놓은 것.
    - Java 9부터는 없어짐. `module`개념을 이용해 쪼개놨음.

  - `JDK설치경로\jre\lib`에 위치
    - jar.exe를 이용해 압축해제가능
    - `*.jar`는 `*.zip`과 동일해서, 압축해제 프로그램을 이용해서도 볼 수 있음


<br>

## 3.2 패키지의 선언

- 패키지는 소스파일에 첫 번째 문장(주석 제외)으로 **<u>단 한번</u>** 선언한다.
- 선언 방식: `package 패키지명;`
  - 클래스명과 쉽게 구분하기 위해 소문자로 선언

- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
  - **<u>하나의 소스파일에 단 하나의 `public` 클래스만 허용한다.</u>**
  - <u>해당 클래스는 소스파일과 이름이 일치해야 함</u>
- 모든 클래스는 하나의 패키지에 속하며, 패키지가 선언되지 않은 클래스는 자동적으로 이름없는(`unnamed`) 패키지에 속하게 된다.
  - 이클립스는 `default`패키지 라고 하는듯
- 해당 패키지의 클래스를 실행하기 위해서는 **클래스의 이름 앞에 패키지 이름을 붙여줘야한다!**
  - 그리고 접근하기 위해서는 **패키지루트 디렉토리에서 수행해야**
  - 그렇지만 매번 이동하는 것은 불편하므로, `classpath`를 설정해준다.


<br>

## 3.3 클래스패스(`classpath`) 설정

- 클래스패스(`classpath`)는 클래스파일(`*.class`)를 찾는 경로
- 환경변수 `classpath`로 관리하며, 경로간의 구분자는 ‘`;`’
  - `classpath`에 패키지의 루트를 등록해줘야 함
- 클래스패스에 패키지가 포함된 폴더나 jar파일을(`* .jar`) 나열한다.
- 클래스패스가 없으면 자동적으로 현재 폴더가 포함되지만 클래스패스를 지정할 때는 현재 폴더(`.`)도 함께 추가해주어야 한다.
- 클래스패스로 자동 포함된 폴더 for **클래스파일**(`*.class`) : **<u>수동생성</u>** 해야함.
  - `JDK설치경로\jre\classes`
- 클래스패스로 자동 포함된 폴더 for **jar파일**(`*.jar`) : **<u>JDK설치시 자동생성됨.</u>**
  - `JDK설치경로\jre\lib\ext`

> _**JAR**(Java Archive, 자바 아카이브)는 여러개의 자바 클래스 파일과, 클래스들이 이용하는 관련 리소스(텍스트, 그림 등) 및 메타데이터를 하나의 파일로 모아서 자바 플랫폼에 응용 소프트웨어나 라이브러리를 배포하기 위한 소프트웨어 파일 포맷이다._

<br>

## 3.4 `import`문

- 사용할 클래스가 속한 패키지를 지정하는데 사용
- `import`문을 사용하면 클래스를 사용할 때 **패키지명을 생략**할 수 있다.
- `java.lang` 패키지의 클래스는 import하지 않고도 사용할 수 있다.
  - `String, Object, System, Thread, ...`
    - 기본 패키지이기 때문에 바로 사용 가능
    - 원래는 `import java.lang.*;`을 써야지만 모든 프로그램에서 이 `import`문은 생략 가능

<br>

## 3.5 `import`문의 선언

- `import`문은 패키지문과 클래스선언의 사이에 선언한다.
- 따라서 일반적인 소스파일(`*.java`)의 구성은 다음의 순서로 되어 있다
  1. `pakage`문
  2. `import`문
  3. `class` 선언
- 선언 방법:
  - `import 패키지명.클래스명;`
  - `import 패키지명.*;`
    - `*`: 모든 클래스
  - 이클립스의 경우 `ctrl+shift+o`를 누르면 자동으로 필요한 `import`문 삽입
- 아래의 코드는 의미가 다르다.
- `import java.*;`는 java 패키지의 모든 클래스를 포함시키지만
  하위 패키지는 포함이 안된다!

```java
import java.sql.*;
import java.util.*;

import java.*;
```

- import는 컴파일 시에 처리되므로 프로그램의 성능에 아무런 영향을 미치지 않는다.
- <u>이름이 같은 클래스가 속한 두 패키지</u>를 import할 때는 **<u>클래스 앞에 패키지명을 붙여줘야</u>** 한다.

```java
import java.sql.*;
import java.util.*;

public class ImportTest {
    public static void main(String[] args) {
        java.util.Date today = new java.util.Date();
    }
}
```

<br>

## 3.6 `static import`문

- `static`멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
  - `static` 변수와 `static` 메서드 모두 해당
- 꼭 필요할 때만 쓸 것.

```java
import static java.lang.Integer.*; //Integer클래스의 모든 static 메서드 참조가능
import static java.lang.Math.random; //Math.random()만. 괄호 안붙임.
import static java.lang.System.out;	//System.out을 out만으로 참조가능
```



<br>

---

<br>

# 4. 제어자

## 4.1 제어자란?

- 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다.
- 제어자는 크게 접근 제어자와 그 외의 제어자로 나뉜다.
- 하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, <u>접근제어자는 단 하나만 사용할 수 있다.</u>
  - 접근 제어자를 항상 가장 왼쪽에 쓰는 관습이 있다.
  - `static`을 `final`보다 왼쪽에 쓰는 관습이 있다.

> 접근 제어자: `public`, `protected`, `default`, `private`
>
> 그 외: `static`, `final`, `abstract`, `native`, `transient`, `synchronized`, `volatile`, `strictfp`

<br>

## 4.2 `static` - 클래스의, 공통적인

- `static`이 사용될 수 있는 곳 - **멤버변수, 메서드, 초기화 블럭**
- `static` 메소드는 **<u>오버라이드 할 수 없다.</u>**
  - 단 `@Override annotation`을 지우고 <u>`Hiding`이란 기법으로 오버라이드가 가능</u>하지만 **<u>객체지향에 있어 바람직한 모습이 아니다.</u>**


| 제어자     | 대상     | 의미                                                         |
| ---------- | -------- | ------------------------------------------------------------ |
| **static** | 멤버변수 | - 모든 인스턴스에 공통으로 사용되는 클래스변수가 된다. 하나의 변수를 모든 인스턴스가 공유.<br />- 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.<br />- 클래스가 메모리에 로드될 때 생성된다. (Method Area) |
| **static** | 메서드   | - 인스턴스를 생성하지 않고도 호출이 가능한 `static` 메서드가 된다.<br />- `static`메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다. 메소드 내에 따로 클래스를 인스턴스화하고 사용해야 한다.<br />- 인스턴스 멤버를 사용하지 않는 메소드는 `static`을 붙여서 `static` 메소드로 선언하는 것을 고려해야 한다.<br />- 가능하다면 `static` 메소드로 하는 것이 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠르다. |

<br>

## 4.3 `final` - 마지막의, 변경될 수 없는

- `final`이 사용될 수 있는 곳 - **클래스, 메서드, 멤버면수, 지역변수**
- `String`, `Math` 클래스가 대표적인 `final` 클래스

| 제어자    | 대상               | 의미                                                         |
| --------- | ------------------ | ------------------------------------------------------------ |
| **final** | 클래스             | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.<br />`final`로 지정된 클래스는 다른 클래스의 parent가 될 수 없다. |
| **final** | 메서드             | 변경될 수 없는 메서드.<br />`final`로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. |
| **final** | 멤버변수, 지역변수 | 값을 변경할 수 없는 상수.                                    |

<br>

## 4.4 생성자를 이용한 `final` 멤버변수 초기화

- `final`이 붙은 변수는 상수이므로 보통은 선언과 초기화를 동시에 하지만, <u>인스턴스변수의 경우 생성자에서 초기화 할 수 있다.</u>
  - 상수지만 선언과 함께 초기화 하지 않고, 생성자에서 단 한번만 초기화할 수 있다.
  - 클래스 내에 매개변수를 갖는 생성자를 생성해 인스턴스를 생성할 때 `final`이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것
  - 각 인스턴스마다 `final`이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능하다.

![image-20220119145611105](Chapter-7 객체지향개념/image-20220119145611105.png)

<br>

## 4.5 `abstract` - 추상의, 미완성의

- `abstract`가 사용될 수 있는 곳 - **클래스, 메서드**

| **제어자**   | **대상** | **의미**                                                     |
| ------------ | -------- | ------------------------------------------------------------ |
| **abstract** | 클래스   | 클래스 내에 추상메서드가 선언되어 있음을 의미<br />추상메서드가 없는 클래스도 추상클래스로 선언 가능하지만 그렇게 해야 할 이유는 없다. |
| **abstract** | 메서드   | 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 의미 |

```java
abstract class AbstractTest {	// 추상클래스
    abstract void move();		// 추상메서드
}
```

- `abstract` 클래스는 미완성 설계도와 같음
  - 메소드 내용이 구현되지 않았으니 당연히 인스턴스 생성불가
  - 추상클래스를 상속받은 완전한 클래스를 만들어야 객체 생성 가능
- 가끔은 완성된 클래스(추상 메소드가 없는 클래스)도 `abstract`를 붙여서 추상클래스로 만드는 경우가 있다. 추상 메소드가 없는 클래스를 상속하여 원하는 메소드만 오버라이딩해도 되는 장점이 있기 때문이다. 만일 이 클래스가 없다면 아무런 내용도 없는 메소드를 잔뜩 오버라이딩 해야 한다.

<br>

## 4.6 접근 제어자(access modifier)

- 멤버 또는 클래스에 사용되어, 외부로부터의 접근을 제한한다.
- 접근 제어자가 사용될 수 있는 곳 - **클래스, 멤버변수, 메서드, 생성자**
  - 클래스는 `public` / `default`
  - 멤버 변수 앞에는 4개 다 사용 가능

> - `private`: **<u>같은 클래스</u>** 내에서만 접근이 가능하다. (파일 범위)
> - `default`: **<u>같은 패키지</u>** 내에서만 접근이 가능하다. (폴더 범위)
> - `protected`: **<u>같은 패키지</u>** 내에서, 그리고 **<u>다른 패키지의 Child클래스</u>**에서 접근이 가능하다.
> - `public`: 접근 제한이 전혀 없다.

<br>

## 4.7 접근 제어자를 이용한 캡슐화

- 접근 제어자를 사용하는 이유:
  - 외부로부터 데이터를 보호하기 위해서
  - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

> *접근 제어자를 이용한 캡슐화, 접근 제어자를 사용하는 이유는 클래스 내부에 선언된 데이터를 보호하기 위해서이다. 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다. 이것을 데이터 감추기(data hiding)이라고 하며, 객체지향개념의 캡슐화 (encapsulation)에 해당하는 내용이다.*

<br>

## 4.8 생성자의 접근 제어자

- 일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치한다.
- 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.

![image-20220120232116743](Chapter-7 객체지향개념/image-20220120232116743.png)

<br>

## 4.9 제어자의 조합

| 대상     | 사용가능한 제어자                         |
| -------- | ----------------------------------------- |
| 클래스   | `public`, (default), `final`, `abstract`        |
| 메서드   | 모든 접근 제어자, `final`, `abstract`, `static` |
| 멤버변수 | 모든 접근 제어자, `final`, `abstract`, `static` |
| 지역변수 | `final`                                     |

1. 메서드에 `static`과 `abstract`를 함께 사용할 수 없다.
   - `static`메서드는 몸통(구현부)이 있는 메서드만 사용 가능
2. 클래스에 `abstract`과 `final`을 동시에 사용할 수 없다.
   - 클래스에 사용되는 `final`은 클래스를 확장할 수 없다는 의미이고, `abstract`는 상송을 통해서 완성되어야 한다는 의미이므로 서로 모순됨
3. `abstract`메서드의 접근제어자가 `private`일 수 없다.
   - `abstract`메서드는 Child클래스에서 구현해주어야 하는데 접근 제어자가 `private`이면, Child클래스에서 접근할 수 없기 때문이다.
4. 메서드에 `private`과 `final`을 같이 사용할 필요는 없다.
   - 접근 제어자가 `private`인 메서드는 오버라이딩될 수 없기 때문
   - 이 둘 중 하나만 사용해도 의미가 충분하다

<br>

---

<br>

## 4.+ 캡슐화와 접근 제어자

- 접근 제어자를 사용하는 이유
  - 외부로부터 데이터를 보호하기 위해서
- 접근 제어자를 통한 **<u>캡슐화</u>**
  - 외부 접근을 막고 메소드를 통한 간접접근을 허용
  - 잘못된 데이터가 되는 것을 막음
  - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위함
  - 접근 제어자 범위를 최소화해두고 천천히 넓혀나가는 식으로 구성하는 것이 좋다.

<br>

---

<br>

# 5. 다형성(polymorphism)

## 5.1 다형성(polymorphism)이란?

- **<u>하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것</u>**
- 즉, <u>**Parent타입의 참조변수로** Child타입의 객체를 다룰 수 있는 것</u>
  - Parent타입의 참조변수로 Child타입의 인스턴스를 참조할 수 있지만,
  - 반대로 **<u>Child타입의 참조변수Parent타입의 인스턴스를 참조할 수 는 없다.</u>**
  - _"하위 객체의 참조변수에 상위 객체의 인스턴스를 할당할 수 없다."_
  
- 참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 결정한다.
  - Parent타입의 참조변수로 Child타입의 객체를 다룰 때는 <u>Parent타입에만 존재하는 내용을 다룰 수 있다.</u>

- 모든 참조변수는 null 또는 4 byte의 주소값이 저장된다.
- 참조변수와 인스턴스의 타입은 일치하는 것이 보통이지만, 다형성에 의해 일치하지 않는 경우도 생길 수 있다.

![image-20220121130434040](Chapter-7 객체지향개념/image-20220121130434040.png)

![image-20220121130445685](Chapter-7 객체지향개념/image-20220121130445685.png)

![image-20220121130459130](Chapter-7 객체지향개념/image-20220121130459130.png)

<br>

## 5.2 참조변수의 형변환

- 서로 상속관계에 있는 타입간의 형변환만 가능
- Child 타입의 참조변수를 Parent 타입의 참조변수로 형변환 = `Up-casting` (형변환 생략 가능)
- Parent 타입의 참조변수를 Child 타입의 참조변수로 형변환 = `Down-casting` (형변환 생략 불가)
  - 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에, **참조변수의 형변환은 인스턴스에 아무 영향 없다.**
    - <u>인스턴스의 멤버변수를 보고, 그보다 적은 수의 멤버를 가진 type으로만 변환가능한게 중요!</u>
  - 컴파일 시, 참조변수 간의 타입만 체크하기 때문에 실행 시 생성될 인스턴스의 타입에 대해서는 알지 못하여 **컴파일은 성공하더라도 실행 시 에러(`ClassCastException`)가 발생할 수 있다.**

<br>

## 5.3 `instanceof`연산자

- 참조변수가 참조하는 인스턴스의 실제 타입을 체크하는데 사용
  - **<u>형변환 가능여부 확인</u>**
- 이항연산자, 피연산자는 `참조형변수`와 `타입`.
  - 연산 결과: `true` or `false`
  - ex)`a instanceof Apple`
- `instanceof`의 연산결과가 `true`이면 해당 타입으로 형변환 가능
  - 참조변수(리모컨)을 변경함으로써 사용할 수 있는 멤버의 갯수를 조절

<br>

## 5.4 참조변수와 인스턴스변수의 연결

- 멤버변수가 중복정의된 경우
  - **<u>참조변수의 타입에 따라 연결되는 멤버변수가 달라진다.</u>**
  - (참조변수타입에 영향받음)
- 메서드가 중복정의된 경우
  - 참조변수의 타입에 관계없이 항상 **<u>실제 인스턴스의 타입에 정의된 메서드가 호출</u>**된다.
  - (참조변수타입에 영향받지 않음)

![image-20220121134156608](Chapter-7 객체지향개념/image-20220121134156608.png)

<br>

## 5.5 매개변수의 다형성

- 참조형 매개변수는 메서드 호출시, **<u>자신과 같은 타입 또는 Child타입</u>**의 인스턴스를 넘겨줄 수 있다.
  - **'다형적 매개변수'**

![image-20220121134543465](Chapter-7 객체지향개념/image-20220121134543465.png)

<br>

## 5.6 여러 종류의 객체를 하나의 배열로 다루기

- **Parent타입의 배열에 Child타입의 객체를 담을 수 있다.**

<br>

### 5.6.1 `java.util.Vector`

- 모든 종류의 객체들을 저장할 수 있는 클래스
- **<u>가변 배열 기능</u>**을 가짐
  - `add()`를 이용해 늘였다 줄였다
- `Object`배열을 가짐 →**<u>모든 종류의 객체 저장 가능</u>**

| 메서드 / 생성자          | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Vector()                 | 10개의 객체를 저장할 수 있는 Vector 인스턴스를 생성<br />10개 이상의 인스턴스가 저장되면 자동적으로 크기 증가 |
| boolean add(Object o)    | Vector에 객체를 추가, 성공 여부에 따른 true/false 반환       |
| boolean remove(Object o) | Vector에 저장되어 있는 객체 제거, 성공 여부에 따른 true/false 반환 |
| boolean isEmpty()        | Vector가 비어있는지 검사하여 true/false 반환                 |
| Object get(int index)    | 지정된 위치(index)의 객체 반환<br />반환타입은 Object타입이므로 형변환 필요 |
| int size()               | Vector에 저장된 객체의 개수 반환                             |

```java
public class Vector extends AbstractList
    	implements List, Cloneable, java.io.Serializable {
    protected Object elementData[];
    ...
}
```

- 자세한 건 11장에서.

<br>

---

<br>

# 6. 추상클래스(abstract class)

## 6.1 추상클래스(abstract class)란?

> _추상: 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용_

- 클래스가 설계도라면 추상클래스는 **<u>`미완성 설계도`</u>**
- 추상메서드(미완성 메서드)를 포함하고 있는 클래스

  > 추상메서드: 선언부만 있고 구현부(몸통, body)가 없는 메서드

- 일반메서드가 **추상메서드를 호출할 수 있다.**(호출할 때 필요한 건 선언부)
- 완성된 설계도가 아니므로 **인스턴스를 생성할 수 없다.**
  - 상속을 통해 추상 메서드를 완성해야 인스턴스 생성 가능
- 다른 클래스를 작성하는 데 **도움을 주기 위한 것**
- 키워드 `abstract`를 사용

```java
abstract class CLASSNAME {}
```



<br>

## 6.2 추상메서드(abstract method)란?

- 선언부만 있고 구현부(몸통, body)가 없는 메서드
  - 괄호`{}`대신 세미콜론`;`으로 끝난다.

- **꼭 필요하지만 Child마다 다르게 구현될 것으로 예상되는 경우**에 사용
- 추상클래스를 상속받는 **Child클래스에서 추상메서드의 구현부를 완성해야**
  한다.

```java
abstract ret-type method_name();
```

<br>

## 6.3 추상클래스의 작성

- **여러 클래스에 공통적으로 사용될 수 있는 추상클래스**를 바로 작성하거나 
- **기존 클래스의 공통 부분**을 뽑아서 추상클래스를 만든다.
  - 관리(변경)이 용이해짐
  - 설계도를 쉽게 작성
  - 중복제거
  - 단계를 나눠서 추상클래스를 작성하면 중간에 해당되는 단계를 골라 구현하기 좋아진다.


![image-20220121160050394](Chapter-7 객체지향개념/image-20220121160050394.png)

![image-20220121164416373](Chapter-7 객체지향개념/image-20220121164416373.png)

- 추상화 ↔ 구체화
  - 추상화된 코드는 구체화된 코드보다 유연하다. 변경에 유리.

<br>

---

<br>

# 7. 인터페이스(interface)

## 7.1 인터페이스(interface)란?

- 일종의 추상클래스. 추상 메서드의 집합!
  - **추상클래스(미완성 설계도)보다 추상화 정도가 높다.**
- **<u>실제 구현된 것이 전혀 없는 `기본 설계도`.(`알맹이 없는 껍데기`)</u>**
- 추상메서드와 상수만을 멤버로 가질 수 있다.
  - 멤버 변수(인스턴스 변수)를 가질 수 없다. Nothing..
- 인스턴스를 생성할 수 없고, 클래스 작성에 도움을 줄 목적으로 사용된다.
- **<u>미리 정해진 규칙에 맞게 구현하도록 표준을 제시</u>**하는 데 사용된다.

<br>

## 7.2 인터페이스의 작성

- `class`대신 `interface`를 사용한다는 것 외에는 클래스 작성과 동일하다.
- **<u>구성요소(멤버)는 추상메서드와 상수만 가능</u>**
  - 모든 멤버변수는 **<u>`public static final`</u>**이어야 하며, 이를 **생략할 수 있다.**
  - 모든 메서드는 **<u>`public abstract`</u>**이어야 하며, 이를 **생략할 수 있다.**
  - _JDK 1.8부터는 디폴트 메서드, static 메서드를 가질 수 있다._

```java
interface interface_name {
    public static final 타입 상수이름 = 값;
    public abstract method_name(parameter);
}
```



<br>

## 7.3 인터페이스의 상속

- 클래스처럼 상속이 가능
  - 인터페이스로부터만 상속
  - 클래스와 다르게 **<u>다중상속 허용</u>**
    - 추상 메서드는 몸통이 없기 때문에 충돌해도 문제 없음
- 인터페이스는 Object클래스와 같은 최고조상이 없다.

```java
interface Moveable {
	void move(int x, int y);
}

interface Attackable {
	void attack(Unit u);
}

interface Fightable extends Moveable, Attackable { }
```



<br>

## 7.4 인터페이스의 구현

- 인터페이스를 구현하는 것은 클래스를 상속받는 것과 같다.
  - 다만 `extends` 대신 `implements`를 사용
- 인터페이스에 정의된 추상메서드를 완성해야 한다.
  - 일부만 구현할 경우 클래스 앞에 `abstract`를 붙인다.
- 상속과 구현이 동시에 가능하다.

```java
class ClassName implements InterfaceName{
    //인터페이스에 정의된 추상메서드 구현
}

class ClassName extends ParentName implements InterfaceName{
    //인터페이스에 정의된 추상메서드 구현
}
```



<br>

## 7.5 인터페이스를 이용한 다형성

- **인터페이스 타입의 변수**로 **<u>인터페이스를 구현한 클래스의 인스턴스를 참조할 수 있다.</u>**
  - 인터페이스도 구현 클래스의 Parent!
  - 대신 인터페이스에 정의된 멤버만 사용 가능.


```java
class Fighter extends Unit implements Fightable {
    public void move(int x, int y) { /*생략*/}
    public void attack(Fightable f) { /*생략*/}
}
```

- 인터페이스를 메서드의 매개변수 타입으로 지정할 수 있다.
  - 매개변수로 해당 인터페이스를 구현한 클래스의 인스턴스만 가능하다는 의미


```java
void attack(Fightable f) {
    // Fightable인터페이스를 구현한 클래스의 인스턴스를
    // 매개변수로 받는 메서드
    /*생략*/
}
```

- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다.

```java
Fightable method() {
    //Fightable인터페이스를 구현한 클래스의 인스턴스를 반환
    /*생략*/
    return new Fighter();
}
```



<br>

## 7.6 인터페이스의 장점과 단점

1. **개발시간을 단축시킬 수 있다.**
   - 일단 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다. <u>메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문</u>이다.
   - 그리고 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하도록 하여, <u>인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다.</u>
2. **변경에 유리한 유연한 설계가 가능하다.**
3. **표준화가 가능하다.**
   - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 <u>보다 일관되고 정형화된 프로그램의 개발이 가능하다.</u>
4. **서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.**
   - 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 <u>서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.</u>
5. **독립적인 프로그래밍이 가능하다.**
   - 인터페이스를 이용하면 <u>클래스의 선언과 구현을 분리</u>시킬 수 있기 때문에 <u>실제구현에 독립적인 프로그램을 작성하는 것이 가능하다.</u>
   - 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, <u>한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍</u>이 가능하다.


<br>

## 7.7 인터페이스의 이해

- **인터페이스는...**
  - 두 대상(객체) 간의 `연결, 대화, 소통`을 돕는 `중간 역할`을 한다.
  - **선언(설계)와 구현을 분리시키는 것을 가능하게 한다.**
- 인터페이스를 이해하려면 먼저 두 가지를 기억하자.
  - 클래스를 사용하는 쪽(`User`)과 클래스를 제공하는 쪽(`Provider`)이 있다.
  - 메서드를 사용(호출)하는 쪽(`User`)에서는 사용하려는 메서드(`Provider`)의 선언부만 알면 된다.

- 직접적인 관계의 두 클래스(A-B)

```java
class A {
    public void methodA(B b) {
        b.methodB();
    }
}

class B {
    public void methodB() {
        System.out.println("methodB");
    }
}

class InterfaceTest {
    public static void main(String args[]) {
        A a = new A();
        a.methodA(new B());
    }
}
```

- 간접적인 관계의 두 클래스(A-I-B)
  - I의 내용을 구현하는 B를 C로 변경하더라도 영향이 적어진다!


```java
class A {
    public void methodA(I i) {
        i.methodB();
    }
}

interface I { void methodB(); }

class B implements I{
    public void methodB() {
        System.out.println("methodB");
    }
}

class C implements I{
    public void methodB() {
        System.out.println("methodB in C");
    }
}

class InterfaceTest {
    public static void main(String args[]) {
        A a = new A();
        a.methodA(new B());
    }
}
```

<br>

## 7.8 디폴트 메서드와 `static` 메서드

- JDK 1.8부터는 **<u>디폴트 메서드, static 메서드</u>**를 추가할 수 있도록 변경
- 인터페이스에 <u>새로운 메서드(추상 메서드)를 추가하는 것은 어려움</u>
  - 이미 해당 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현 해야 하기 때문
- 이런 문제를 해결하기 위해 디폴트 메서드(`default method`)를 고안
  - 디폴트 메서드(`default method`): 인터페이스에 추가된 **<u>일반 메서드</u>**
    - 기존의 인터페이스 원칙 위반
    - 앞에 키워드 `default`를 붙이며 일반 메서드처럼 몸통`{}`이 있어야 한다.
    - 접근 제어자는 `public`이며 생략 가능

```java
interface MyInterface{
    void method();
    default void newMethod(){}
}
```

- 디폴트 메서드(`default method`)가 기존의 메서드와 이름이 중복되어 충돌할 때의 해결책
  1. **여러 인터페이스의 디폴트 메서드**간의 충돌
     - 인터페이스를 구현한 클래스에서 **<u>디폴트 메서드를 오버라이딩</u>** 해야 한다.
  2. **디폴트 메서드와 조상 클래스의 메서드** 간의 충돌
     - 조상 클래스의 메서드가 상속되고, **<u>디폴트 메서드는 무시</u>**된다.
  3. 외우기 힘들면 그낭 <u>필요한 쪽의 메서드와 같은 내용으로 오버라이딩 하면 된다</u>..

<br>

---

<br>

# 8. 내부 클래스

## 8.1 내부 클래스(`inner class`)

- 클래스 내에 선언된 클래스

```java
class A{ //외부 클래스
    ...
    class B{ //내부 클래스
        ..
    }
    ...
}
```

- 장점
  - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다
  - 코드의 복잡성을 줄일 수 있다(캡슐화)


<br>

## 8.2 내부 클래스의 종류와 특징

- 내부 클래스의 종류와 유효 범위(scope)는 **<u>변수와 동일하거나 유사함</u>**

| 내부 클래스                                | 특징                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 인스턴스 내부 클래스<br />(instance class) | 외부 클래스의 멤버변수 선언 위치에 선언<br />외부 클래스의 인스턴스 멤버처럼 사용<br />주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용할 목적으로 선언 |
| static 내부 클래스<br />(static class)     | 외부 클래스의 멤버변수 선언 위치에 선언<br />외부 클래스의 `static` 멤버처럼 사용<br />외부 클래스의 `static` 멤버, 특히 `static` 메서드에서 사용될 목적으로 선언 |
| 지역 내부 클래스<br />(local class)        | 외부 클래스의 메서드나 초기화 블럭 안에 선언<br />선언된 영역 내부에서만 사용 가능 |
| 익명 클래스<br />(anonymous class)         | 클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스.(일회용) |

<br>

## 8.3 내부 클래스의 선언

- 내부 클래스의 선언위치는 변수의 선언위치와 동일
- 각 클래스의 선언 위치에 따라 변수와 동일한 유효범위(scope)와 접근성(accessibility)를 갖는다.

![img](Chapter-7 객체지향개념/img.png)

<br>

## 8.4 내부 클래스의 제어자와 접근성

- 내부 클래스의 제어자는 변수에 사용 가능한 제어자와 동일
- 내부 클래스도 클래스이기 때문에 `abstract`나 `final`과 같은 제어자 사용 가능
- 멤버 변수처럼 접근 제어자 4개를 모두 사용 가능
  - `static` 내부 클래스만 `static` 멤버를 정의 가능
  - `final static`은 상수이므로 허용

<br>

---

<br>

# 9. 익명클래스(`Anonymous` Class)

## 9.1 익명클래스(`Anonymous` Class)란?

- `InnerClass`의 한 종류,  **<u>클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스.</u>**
- "이름이 없는 객체"
  - 이름이 없다는 것 == 별로 기억되지 않아도 된다, 나중에 다시 불러질 이유가 없다
- **프로그램에서 일시적으로 한번만 사용되고 버려지는 객체**
  - 이름이 없다는 것 = 일시적으로 사용된다 = 별로 기억되지 않아도 된다, 나중에 재사용이 되지 않는다
  - 재사용이 될 필요가 없다 = 확장성이 그렇게 좋지 못하다는 뜻
- **익명 자식 객체에서 새롭게 정의된 필드와 메소드는 자식객체 레벨에서만 사용되기 때문에 외부에서는 사용할 수 없다.**

<br>

## 9.2 익명클래스를 사용하는 이유

- 자바에서 확장성을 고려해서 코딩을 하고 설계를 하는 것도 중요
- 하지만, 최소한의 확장성이 성립되려면 어느정도 유지보수에 대한 이점이 있어야함
  - **오히려 확장성을 고려해서 설계를 했다간 유지보수에서 더 불리한 경우가 있다.**

- 익명 클래스를 사용하는 가장 큰 목적은 <u>부모 클래스를 상속받는 서브 클래스를 생성하지 않고도, **단일 객체**를 만들어서 부모 클래스에 정의된 동작에서 행위를 추가할 수 있다는 것.</u>
- 익명 클래스는 그래픽 프로그래밍을 할 때 리스너 인터페이스를 만들 때 유용하다.

<br>

## 9.3 익명클래스를 사용하는 경우

1. **프로그램 내에서 일시적으로(단발성으로) 한번만 사용되어야 하는 객체일 경우** 
   - UI 이벤트처리, 스레드 객체 등 (단발성 이벤트 처리)
2. **재사용성이 없고, 확장성을 활용하는 것이 유지보수에서 더 불리할 때**
   - 비즈니스 로직이 정말 제각각이며, 재사용성이 전혀없어 매번 클래스를 생성해야하는 비용이 더 많을때

<br>

## 9.4 익명클래스 구현하는 방법

- 익명 클래스는 **클래스와 인터페이스로부터** 만들 수 있다.
  - 부모/자식간 상속아래 익명 자식객체를 생성할 것인가?
  - 아니면, 인터페이스를 구현한 익명 구현객체를 생성할 것인가? 

```java
new ParentClassName() {
    //멤버 선언
}

new 구현InterfaceName() {
    //멤버 선언
}
```

<br>

### 9.4.1 익명 자식객체

- 아래의 세 가지 방법으로 구현 방법:
  1. 필드의 초기값
  2. 로컬변수의 초기값
  3. 매개변수의 매개값

```java
ParentClass [field|variable] = new ParentClass(parameter, ...) {
    
};
```

- 예제를 위한 부모클래스

```java
package Anonymous;

public class Insect {

	void attack(){
		System.out.println("곤충은 공격을 한다");
	}
}
```

- 예제 코드

```java
public class Anonymous {

	//★★방법 1 : 필드에 익명자식 객체를 생성 
	Insect spider1 = new Insect(){
		
		String name = "무당거미";
		//거미줄을 치다.
		void cobweb(){
			System.out.println("사각형으로 거미줄을 친다.");
		}
		
		@Override
		void attack() {
			System.out.println(name + " 독을 발사한다.");
		}
	};
	
	//★★방법2 : 로컬변수의 초기값으로 대입
	void method1(){
		Insect spider2 = new Insect(){
			
			String name = "늑대거미";
			//거미줄을 치다.
			void cobweb(){
				System.out.println("육각형으로 거미줄을 친다.");
			}
			
			@Override
			void attack() {
				System.out.println(name + " 앞니로 문다.");
			}
		};
		
		//로컬변수이기 때문에 메서드에서 바로 사용
		spider2.attack();
	}
	
	//★★방법3 : 익명객체 매개변수로 대입
	void method2(Insect spider){
		spider.attack();
	}
	
	
}
```

- 예제 코드(2)

```java
public class AnonymousExample {

	public static void main(String[] args) {
		
		Anonymous a = new Anonymous();
		
		//방법 1 : 익명객체 필드 사용
		a.spider1.attack();

		//방법2 : 익명객체 로컬 변수 사용
		a.method1();
		
		//방법3 : 매개변수로 익명개체 사용
		a.method2(new Insect(){
			String name = "타란툴라";
			
			//거미줄을 치다.
			void cobweb(){
				System.out.println("그냥 마구잡이로 친다.");
			}
			
			@Override
			void attack() {
				System.out.println(name + " 공격 안하고 후퇴한다..");
			};
		});
		
		//익명객체 내부에서 새롭게 정의된 필드,메서드는 부모객체로 생성된 spider1에서 접근할 수 없음!!!
		a.spider1.name = "왕거미"; //익명객체에서 새롭게 정의된 필드 (접근불가)
		a.spider1.cobweb(); //익명객체에서 새롭게 정의된 메서드 (접근불가)
		a.spider1.attack(); //부모클래스 Insect에서 오버라이딩해서 재정의한 메서드 (접근가능)
	}

}
```