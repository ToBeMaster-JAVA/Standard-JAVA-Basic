# 5주차 : 『 7장. 객체지향 프로그래밍 Ⅱ 』
## 《 Chap.1 : 상속 ~ Chap.6 : Object클래스 》

**Q1. 다음 내용 중 옳은 것과 틀린 것을 구분하고, 틀린 내용은 왜 틀렸는지 서술하시오.**

```
1. Child클래스는 Parent클래스의 멤버를 상속받는 것으로, 항상 Parent보다 같거나 많은 개수의 멤버를 소유하게 된다. 

2. Child클래스의 인스턴스는 생성될 때 항상 자동으로 Parent클래스의 생성자와 초기화블럭도 같이 실행하게 된다.
- 애매함

3. 상속관계(inheritance)는 곧 포함관계(composite)라 할 수 있다.
- 둘은 다르다.

4. 클래스간의 관계를 결정할 때는 가능한 한 많은 관계를 맺어주는 것이 좋으며, 코드의 재사용성을 높이기 위해 가능한 클래스들은 모두 상속 관계로 포함시켜주는 것이 좋다.
- Java는 단일 상속만 허용하므로, 가장 중요한 것만 상속 관계로 두고 최대한 포함 관계로 이루는 것이 좋다.
```

<br>

**Q2. 아직 완성되지 않은 여러 클래스들이 있다. 주어진 클래스들의 관계(상속&포함)를 결정해보시오.**

- 포함 관계를 위해 인스턴스를 생성할 경우, 변수의 이름은 해당 클래스 이름의 앞글자만 따서 사용할 것.
- `Mamalia: 포유류 / Felidae: 고양잇과 / Cat: 고양이 / Tiger: 호랑이 / Digestive system: 소화기관`

```java
class Mammalia { //상속?
    //...
}

class Felidae { //상속?
    //...
}

class Cat { //상속?
    //...
}

class Tiger { //상속?
    //...
}

class DigestiveSystem { //상속?
    //...
}
```

<br>

---

## 《 Chap.7 : 오버라이딩(overriding) ~ Chap.14 : 클래스 패스(classpath) 》

**Q1. 패키지를 선언하지 않아도 문제가 없던 이유는? 그럼에도 불구하고 패키지 선언을 해야하는 때는?**

- _보통 내부적인 테스트를 진행할 때는 해당 디렉토리에서 실행하기에 패키지를 선언하지 않아도 문제되지 않는다._
  _그러나 개발이 완료되어 외부에서 해당 클래스를 사용하기 위해서는 경로 선언이 필요하기에, 패키지 선언을? 하게된다?_

<br>

**Q2. 조상의 멤버는 조상의 생성자를 통해 초기화되도록 작성하는 것이 바람직하다. 자손 클래스의 생성자에서 조상 클래스의 생성자를 호출해야 하는 이유는 무엇일까?**

- _자손 클래스가 조상 클래스를 상속받을 때, 조상 클래스가 가진 초기화 블럭과 생성자는 같이 상속되지 않는다. 따라서 자손 클래스의 생성자에서 조상의 멤버를 초기화할 때는 조상의 생성자를 이용하는 것이 바람직하다?_

<br>

**Q3. 오버라이딩에 대한 것 중 틀린 것을 고치시오**

```
1. 메서드의 이름, 매개변수, 반환타입은 조상의 메서드와 일치해야 한다
2. 조상의 메서드의 접근제어자가 작성되어 있지 않으면 자손은 아무 제어자나 사용 가능하다
3. 조상 클래스의 메서드보다 예외 수만 적다면 자손의 메서드는 아무 예외나 선언할 수 있다.
4. 조상 클래스의 생성자를 상속하여 자신의 멤버 변수 초기화 코드를 추가한 것은 오버라이딩의 예시이다.
```

- _2, 3, 4._

<br>

---
## 《 Chap.15 : import문 ~ Chap.22 : 캡슐화와 접근 제어자 》

**Q1.** `static` 제어자가 사용될 수 없는 곳은?

> ① 클래스 변수
> ② 메서드
> ③ 초기화 블럭
> ④ 지역 변수

- _③?_

<br>

**Q2.** 접근 제어자를 사용하는 이유 2가지를 서술하시오.

- _외부에서 내부 데이터에 함부로 접근할 수 없도록 데이터를 가리기 위함_
- _외부에서 알 필요 없는 정보를 가리기 위함_

<br>

---
## 《 Chap.23 : 다형성(polymorphism) ~ Chap.30 : 인터페이스의 장점 》

**Q1. 다형성에 대한 설명 중 틀린 것은? (출처 : 명품JAVA 5장 14번)**

```
1) 추상 메소드를 두는 이유는 상속 받는 클래스에서 다형성을 실현하도록 하기 위함이다.  
2) 인터페이스도 구현하는 클래스에서 다형성을 실현하도록 하기 위함이다.  
3) 다형성은 서브클래스들이 슈퍼클래스의 동일한 메소드를 서로 다르게 오버라이딩하여 이루어진다.  
4) 자바에서 다형성은 모호한(ambiguous) 문제를 일으키므로 사용하지 않는 것이 바람직하다.  
5) 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.  
```

- _4_

<br>

**Q2. A와 B에 들어갈 답은?**

```
서로 상속 관계에 있는 타입 간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
그래서 참조변수가 가리키는 인스턴스의 실제 타입이 무엇인지 [ A ] 연산자를 사용한다.
어떤 타입에 대한 [ A ] 연산의 결과가 [ B ]라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다. 
```

- _A: `instanceof`_
- _B: `true`_

---
## 《 Chap.31 : 추상 클래스(abstract class) ~ Chap.39 : Object클래스 》

**Q1. 추상 클래스와 추상 메서드에 대한 설명으로 틀린 것을 모두 고르시오.(2개)**

```
1) 추상 클래스는 미완성 메서드를 포함하는 클래스이다.
2) 추상 클래스에 대한 인스턴스를 생성할 수 있다.  
3) 추상 클래스는 자손 클래스에 의해 완성된다.  
4) 추상 메서드는 선언부는 작성하고 구현부만 비워둔 메서드이다.
5) 자손 클래스는 오버로딩을 통해 추상 메서드를 구현할 수 있다.   
```

- _2, 5_

<br>

**Q2. 인터페이스에 대한 설명으로 틀린 것을 모두 고르시오.(2개)**

```
1) 추상 메서드와 상수 만을 멤버로 가지는 일종의 추상 클래스이다.
2) 인터페이스 작성 시 인터페이스명 앞에 'interface'를 붙여 작성할 수 있다.  
3) 인터페이스는 단일 상속만이 가능하다.
4) 인터페이스의 추상 메서드 구현 시 클래스를 확장한다는 의미의 'extends'를 사용한다.
5) 인터페이스의 추상 메서드 중 일부만을 구현한 클래스는 추상 클래스가 된다.
6) 인터페이스의 상속은 인터페이스로부터만 가능하다.
7) 인터페이스의 상속과 구현은 동시에 가능하다.
```

- _3, 6_

<br>

---
## 《 Chap.40 : 내부 클래스의 제어자와 접근성 ~ Chap.50 : 예제 》

**Q1. Default method의 특징을 쓰시오.**

- _인터페이스에는 추상 메소드나 상수만이 정의 가능했으나, default method는 인터페이스에서 정의되는데도 불구하고 몸통의 정의가 가능하다. 이것으로 여러 클래스에서 상속받아 사용중인 인터페이스에 새로운 함수를 추가할 때, 조금 더 유지보수가 편한 방식으로 추가할 수 있게 되었다._

<br>

**Q2. Default method가 기존 method와 충돌하는 경우의 규칙 중 틀린 것을 고르시오.**

```
1) 필요한 쪽의 메서드와 같은 내용으로 오버라이딩한다.
2) 디폴트 메서드가 무시되고, 조상 클래스의 메서드가 상속된다.
3) 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 한다.
4) 조상 클래스의 메서드가 무시되고, 디폴트 메서드가 상속된다.
```

- _4_

<br>

**Q3. 다음 내부 클래스의 종류와 특징 중 맞는 것을 모두 고르시오.**

```
1) 스태틱 클래스는 외부 클래스의 인스턴스 멤버를 객체 생성없이 사용할 수 없다. 
2) 인스턴스 클래스는 주로 내부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적이다.
3) 스태틱 클래스는 외부 클래스의 멤버 변수 선언 위치에 선언한다.
4) 지역 클래스는 내부 클래스의 메서드 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.
5) 익명 클래스는 클래스의 선언을 먼저하고 객체를 생성한다.
6) 내부 클래스에서는 abstract나 final 제어자를 사용할 수 없다.
7) final과 static이 동시에 붙은 변수는 모든 내부 클래스에서 정의가 불가능하다.
8) 내부 클래스는 멤버 변수들처럼 private, protected 접근제어자를 사용할 수 있다.
9) 지역 클래스는 외부 클래스의 인스턴스 멤버와 스태틱 멤버를 사용할 수 없다.
```

- _2, 3, 4, 7, 9_

---
## 《 Chap.51 : 익명 클래스 ~ Chap.52 : 예제 》

**Q1.다음은 이름이 없는 클래스에 관한 문제이다. O, X를 작성하시오.**

```
(1) 지역 클래스에 대한 설명이다 (X)
(2) 여러번 사용할 수 있다 (X)
(3) 생성자를 가질 수 없다 (X)
(4) 다중 상속이 가능하다 (X)
(5) 컴파일 하면 .class 앞에 숫자가 붙는다 (X)
```

<br>

**Q2. this , this( ), super, super( ) 의 기능을 각각 설명하시오.**

```
this : 인스턴스 자신을 가리키는 참조변수
this( ) : 인스턴스의 생성자
super : 조상 클래스의 멤버를 가리키는데 사용하는 참조변수
super( ) : 조상 클래스의 생성자
```
