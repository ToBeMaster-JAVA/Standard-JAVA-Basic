# 9주차 : 『 11장. 컬렉션 프레임웍』

## 《 Chap.1 : 컬렉션 프레임웍 ~ Chap.10 : ArrayList의 추가와 삭제 》

**Q1. 다음 (ㄱ) ~ (ㅁ)에 대한 답을 적으시오**

```
(ㄱ)인터페이스 : 순서가 있는 데이터의 집합, 데이터의 중복을 허용
(ㄴ)인터페이스 : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음
(ㄷ)인터페이스 : 키와 값의 쌍으로 이루어진 데이터의 집합, 순서는 유지되지 않으며 키는 중복을 허용하지 않고 값은 중복을 허용 
(ㄹ) : (ㄱ)과 (ㄴ)의 공통부분을 추출한 것, 여러 객체를 모아놓은 것을 의미
(ㅁ) : 표준화, 정형화된 체계적인 프로그래밍 방식 

답 : (ㄱ)List, (ㄴ)Set, (ㄷ)Map, (ㄹ)Collection, (ㅁ)framework
```



**Q2. 다음 중 ArrayList에 관해 맞는 것을 모두 고르시오**

```
답 : 1, 3

(1) List인터페이스를 구현한다
(2) 저장순서가 유지되고 중복을 허용하지 않는다
(3) 데이터의 저장공간으로 배열을 사용한다
(4) 자체적으로 동기화 처리되어 있다.

해설
(2) : 저장순서가 유지되고 중복 허용
(4) : Vector는 자체적으로 동기화 처리되어 있으나 ArrayList는 동기화 되어있지 않음
```

---

## 《 Chap.12 : LinkedList ~ Chap.21 : Stack과 Queue의 활용 예제 》

**Q1. 다음 중 옳지 않은 것 2개를 고르시오.**

```
① 자바에서는 스택(Stack)과 큐(Queue)를 각각의 클래스로 정의되어 있다.

② 큐(Queue)의 메서드 중 객체를 꺼내는 `offer()` 와 객체를 삭제없이 읽어오는 `peek()`는 큐가 비어있을 경우, null을 반환한다.

③ LinkedList가 ArrayList보다 추가/삭제가 빠르다.

④ LinkedList는 데이터가 많을수록 접근시간이 길어진다.

⑤ LinkedList는 양방향 이동이 가능하다.
답 : 1, 5 
```



**Q2. 빈 칸에 채워질 단어를 서술하시오.**

```
"스택(Stack)" 은 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 (  )구조로 되어있고,
"큐(Queue)" 는 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 (  )구조로 되어있다.

답 : 
LIFO(Last-In First-Out)
FIFO(First-In First-Out)
```



**Q3. 배열(Array)의 단점 2가지를 서술하시오.**

```
답 :
1. 크기를 변경할 수 없다 / 크기를 변경할 수 없어 새로운 배열을 생성해서 데이터를 복사해야하기 때문에 비효율적이고 큰 크기의 배열을 생성하게 되면 메모리가 비효율적으로 낭비된다.
2. 비순차적인 데이터 추가/삭제에 소요되는 시간이 길다. / 중간에 데이터 추가/삭제에 소요되는 시간이 길다.
```

---

## 《 Chap.22 :  Iterator, ListIterator, Enumeration ~ Chap.29 : Arrays의 메서드 예제 》

**Q1. 인터페이스(ㄱ,ㄴ,ㄷ)와 인터페이스의 기능(a,b,c)을 각각 짝지으시오.**

```
ㄱ. Iterator
ㄴ. Enumeration
ㄷ. ListIterator

a. 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스
b. Iterator에 양방향 조회 기능 추가
c. Iterator의 구버전
```

답 : ㄱ-a , ㄴ-c , ㄷ-b

**Q2. Map인터페이스를 구현한 컬렉션 클래스는 key와 value를 pair로 저장하고 있기 때문에 iterator()를 직접 호출할 수 없다. 이때 Iterator를 얻기위해서는 어떻게 해야하는가?**

답 : Map인터페이스를 구현한 컬렉션 클래스는 key와 value를 pair로 저장하고 있기 때문에 iterator()를 직접 호출할 수 없고, keySet()이나 entrySet()과 같은 메서드를 통해서 키와 값을 각각 따로 Set의 형태로 얻어 온 후에 다시 iterator()를 호출해야 Iterator를 얻을 수 있다.



**Q3. 아래 단어들은 Arrays 메서드인데 각 메서드의 기능을 적으시오. (중요한 키워드만)**

```
1. copyOf(), copyOfRange()  : 배열 복사
2. fill(), setAll() : 배열 채우기
3. sort() : 배열 정렬
4. equals() : 문자열 비교
5. toString() : 문자열 출력
6. asList(Object...a) :  배열을 List로 변환 
```

------

## 《 Chap.30 : Comparator와 Comparable ~ Chap.38 : HashSet 예제 》

**Q1. Comparator와 Comparable에 대해 틀린 것을 고르시오.**

```
4)
comparator를 사용함으로써 내림차순 또는 다른 기준에 의해 정렬되도록 할 수 있다.
```



**Q2. HashSet에 대해 틀린 것을 고르시오.**

```
2) 
hashSet은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 LinkedHashSet을 사용해야 한다.
```

---

## 《 Chap.39 : TreeSet ~ Chap.45 : TreeSet 예제 》

**Q1. `[5, 8, 9, 6, 2, 1, 4 ]`를 순서대로 TreeSet에 저장하면 어떤 구조로 저장되는지 아래 물음표를 채워 나타내시오.**

```yaml
               [?]
           /         \
       [?]             [?]
     /     \         /    \
   [?]     [?]     [?]    [?]
  /   \   /   \   /   \  /   \
 [?] [?] [?] [?] [?] [?] [?] [?]
 ...
 (필요시 아래로 늘릴 것)
```
- 기본적으로 Tree 구조에서 데이터가 어떻게 추가되는지를 이해했는가에 관한 문제.
  - 일반적인 이진트리의 경우를 그려냈다면 정답, TreeSet이 `red-black-tree`로 된 것을 이해하고 그에 따른 경우를 그려낼 수 있다면 가산점이 붙는다.

- 일반적인 이진트리

```yaml
               [5]
           /         \
       [2]             [8]
     /     \         /    \
   [1]     [4]     [6]    [9]
```

- `red-black-tree`로 형태로 구현된 TreeSet의 경우

```yaml
1단계
               [5]
           /         \
       [?]             [8]
     /     \         /    \
   [?]     [?]     [?]    [9]

2단계
               [8]
           /         \
       [5]             [9]
     /     \         /    \
   [?]     [?]     [?]    [?]

3단계
               [8]
           /         \
       [5]             [9]
     /     \         /    \
   [?]     [6]     [?]    [?]

4단계
               [8]
           /         \
       [5]             [9]
     /     \         /    \
   [2]     [6]     [?]    [?]

5단계
               [8]
           /         \
       [5]             [9]
     /     \         /    \
   [2]     [6]     [?]    [?]
  /   \   /   \   /   \  /   \
 [1] [?] [?] [?] [?] [?] [?] [?]

6단계
               [8]
           /         \
       [5]             [9]
     /     \         /    \
   [2]     [6]     [?]    [?]
  /   \   /   \   /   \  /   \
 [1] [4] [?] [?] [?] [?] [?] [?]
```


<br>

**Q2. 아래 내용에 대해 옳은 것과 틀린 것을 구분하고, 틀린 것은 올바르게 고치시오.**

> 1. TreeSet은 이진검색트리 라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스로, `red-black-tree`로 구현되어 있다.
>
>    옳음
>
> 2. TreeSet은 생성자와 함께 주어진 컬렉션을 저장하도록 지정할 수 있다.
>
>    옳음
>
> 3. TreeSet은 데이터의 삽입/삭제 및 정렬, 검색, 범위검색에 있어서 HashSet에 비해 시간적인 이점을 갖는다.
>
>    틀림. 삽입, 삭제의 경우 HashSet보다 오랜 시간이 걸린다.
>
> 4. TreeSet은 오로지 오름차순 정렬로만 저장되며, 이를 변경할 수 없다.
>
>    틀림. 생성자와 함께 정렬 기준을 제공할 수 있다.
>
> 5. TreeSet은 모든 데이터를 반복적인 비교 후, 적절한 위치를 찾아 저장되기 때문에 중복값의 저장에도 문제 없다.
>
>    틀림. 중복값은 저장할 수 없다.

<br>

---

## 《 Chap.46 : HashMap과 Hashtable ~ Chap.51 : HashMap 예제 》

**Q1. HashMap의 메서드 중 1)지정된 키와 값을 HashMap에 저장하는 메서드와 2) 지정된 키의 값을 반환하는 메서드를 적으시오**

```
1)put()

Object put(Object key, Object value) : 지정된 키와 값을 HashMap에 저장하는 메서드

2)get()

Object get(Object key) : 지정된 키의 값을 반환, 못찾으면 null을 반환
```



**Q2. HashMap에 1), 2), 3) 메서드를 적용했을 때 어떤 변화가 일어나는지 적으시오**

```
HashMap map = new HashMap();
1) Set set = map.entrySet();
2) set = map.keySet();
3) Collection values = map.values();
1) map에 저장된 키와 값을 엔트리 형태로 set에 저장
2) map에 저장된 모든 키를 set에 저장
3) map에 저장된 모든 값을 컬렉션 형태로 values에 저장
```

------

## 《 Chap.52 : Collections의 메서드 - `동기화` ~ Chap.56 : 컬렉션 클래스 정리 & 요약 》

**Q1. java.util.Collection과 java.util.Collections에 대해 설명하세요**

java.util.Collection은 최상위 인터페이스로 Set, List, Queue 인터페이스가 이를 구현하고 있다.

(Ex: ArrayList 클래스의 경우 Collection 인터페이스 → List 인터페이스 → ArrayList 클래스 순서로 구현)

java.util.Collections는 클래스로 Collection과 관련된 메소드를 제공한다.

(Ex: fill(), sort(), copy(), binarySearch() 등)



**Q2. 빈칸을 채우세요**

| 기능                                | 메서드       |
| ----------------------------------- | ------------ |
| 동기화 처리                         | synchronized |
| 변경 불가 (읽기 전용 → 데이터 보호) | unmodifiable |
| 단 하나의 객체만 저장               | synchronized |
| 한 종류의 객체만 저장               | checked      |