# 5주차 : 『 7장. 객체지향 프로그래밍 Ⅱ 』
## 《 Chap.1 : 상속 ~ Chap.6 : Object클래스 》

**Q1. 다음 내용 중 옳은 것과 틀린 것을 구분하고, 틀린 내용은 왜 틀렸는지 서술하시오.**

> ```
> 1. Child클래스는 Parent클래스의 멤버를 상속받는 것으로, 항상 Parent보다 같거나 많은 개수의 멤버를 소유하게 된다. (O)
> ```
> ```
> 2. Child클래스의 인스턴스가 생성될 때는 항상 자동으로 Parent클래스의 생성자와 초기화블럭도 같이 실행하게 된다. (?)
>   - Child클래스는 Parent의 멤버 중 생성자와 초기화 블럭을 제외하고 상속받는다.
>   - 그러나 Child클래스의 인스턴스를 생성하면, Child의 멤버와 Parent의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
>   - 조상의 생성자를 명시적으로 호출하지 않더라도 컴파일러가 자동으로 super();를 자손의 생성자에 추가하고, 초기화블럭은 클래스 로딩/인스턴스 생성 과정에서 자동으로 수행된다.
>   - 따라서 자동으로 실행되긴 한다! 다만 책에는 명시적으로 적혀있지 않으므로 맞았다 틀렸다 얘기하기는 조금 모호한 부분이 있는 것 같다.
> ```
> ```
> 3. 상속관계(inheritance)는 곧 포함관계(composite)라 할 수 있다. (X)
>   - 상속관계와 포함관계는 다르다.
>   - 상속: 기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것
>   - 포함: 한 클래스의 멤버변수로 다른 클래스를 선언하는 것
> ```
> ```
> 4. 클래스간의 관계를 결정할 때는 가능한 한 많은 관계를 맺어주는 것이 좋으며, 코드의 재사용성을 높이기 위해 가능한 클래스들은 모두 같이 다중 상속 관계로 포함시켜주는 것이 좋다. (X)
>   - Java는 단일 상속만을 허용하므로, 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 구성하는 것이 좋다.
> ```

<br>

**Q2. 아직 완성되지 않은 여러 클래스들이 있다. 주어진 클래스들의 관계(상속&포함)를 결정해보시오.**

- 포함 관계를 위해 인스턴스를 생성할 경우, 변수의 이름은 해당 클래스 이름의 앞글자만 따서 사용할 것.
- `Mamalia: 포유류 / Felidae: 고양잇과 / Cat: 고양이 / Tiger: 호랑이 / Digestive system: 소화기관`

> 모범 답안:
>
> ```java
> class Mammalia {
>     	DigestiveSystem d = new DigestiveSystem();
> }
> 
> class Felidae extends Mammalia{ 
>     	//...
> }
> 
> class Cat extends Felidae{
>    	//DigestiveSystem d = new DigestiveSystem();
> }
> 
> class Tiger extends Felidae{ 
>    	//DigestiveSystem d = new DigestiveSystem();
> }
> 
> class DigestiveSystem {
>     	//...
> }
> ```
>
> ```java
> class Mammalia {
>     	DigestiveSystem d = new DigestiveSystem();
> }
> 
> class Felidae extends Mammalia{ 
>     	//...
> }
> 
> class Cat extends Felidae{
>    	//...
> }
> 
> class Tiger extends Felidae{ 
>    	//...
> }
> 
> class DigestiveSystem {
>     	//...
> }
> ```

<br>

---

## 《 Chap.7 : 오버라이딩(overriding) ~ Chap.14 : 클래스 패스(classpath) 》

**Q1.** 패키지를 선언하지 않아도 문제가 없던 이유는? 그럼에도 불구하고 패키지 선언을 해야하는 때는?

- 패키지를 선언하지 않아도 자바에서 기본적으로 제공하는 ‘이름 없는 패키지(unnamed package)’에 속하게 되므로
- 큰 규모의 프로젝트나 클래스 라이브러리를 작성하는 경우에는 미리 패키지를 구성해서 적용해야 한다.

<br>

**Q2.** 조상의 멤버는 조상의 생성자를 통해 초기화되도록 작성하는 것이 바람직하다. 자손 클래스의 생성자에서 조상 클래스의 생성자를 호출해야 하는 이유는 무엇일까?

- (자손 클래스의 생성자에서 초기화하기보다는 super()를 사용하여 초기화해야 하는 이유라고 보시면 됩니다) -> 생성자 상속 불가라는 답변을 보고... 문제 수정이 필요할 것 같아서 수정합니다.)

- 각 클래스의 생성자는 해당 클래스에서 선언된 인스턴스 변수의 초기화만을 담당하는 것이 좋기 때문에 조상 클래스로부터 상속 받은 인스턴스의 변수는 조상 클래스의 생성자가 초기화를 해줘야한다. (조상 클래스의 생성자는 조상 클래스의 변수 초기화 담당)

<br>

**Q3.**
오버라이딩에 대한 것 중 틀린 것을 고치시오

```
1. 메서드의 이름, 매개변수, 반환타입은 조상의 메서드와 일치해야 한다
    맞다
2. 조상의 메서드의 접근제어자가 작성되어 있지 않으면 자손은 아무 제어자나 사용 가능하다\
    public과 protected, default만 가능
    public → protected → (default) → private 순으로 좁아지기 때문에, default보다 적은 private로는 변경이 불가하다
3. 조상 클래스의 메서드보다 예외 수만 적다면 자손의 메서드는 새로운 예외를 선언할 수 있다.
    예외 또한 같은 예외여야 한다 
    조상 클래스의 메소드가 상속받은 하위 유형인 자손 클래스의 메소드를 처리할 수 있어야 하는데 새로운 예외가 선언되면 그게 불가능해진다  
4. 조상 클래스의 생성자를 상속하여 자신의 멤버 변수 초기화 코드를 추가한 것은 오버라이딩의 예시이다.
    맞다
```

<br>

---
## 《 Chap.15 : import문 ~ Chap.22 : 캡슐화와 접근 제어자 》

**Q1. `static` 제어자가 사용될 수 없는 곳은?**

① 클래스 변수  
② 메서드  
③ 초기화 블럭  
④ 지역 변수

**답 : ④ 지역 변수**  
풀이 : static 멤버 변수는 모든 인스턴스가 공유하는데 지역변수는 사용 범위가 한정적이다.

<br>

**Q2. 접근 제어자를 사용하는 이유 2가지를 서술하시오.**

**답**
- 데이터 보호  
- 노출 방지( 외부에서 불필요한 부분 / 내부적으로만 사용되는 부분을 공개하지 않기 위해 )

<br>

---
## 《 Chap.23 : 다형성(polymorphism) ~ Chap.30 : 인터페이스의 장점 》

**Q1.** 다형성에 대한 설명 중 틀린 것은? (출처 : 명품JAVA 5장 14번)  

```  
1) 추상 메소드를 두는 이유는 상속 받는 클래스에서 다형성을 실현하도록 하기 위함이다.  
2) 인터페이스도 구현하는 클래스에서 다형성을 실현하도록 하기 위함이다.  
3) 다형성은 서브클래스들이 슈퍼클래스의 동일한 메소드를 서로 다르게 오버라이딩하여 이루어진다.  
4) 자바에서 다형성은 모호한(ambiguous) 문제를 일으키므로 사용하지 않는 것이 바람직하다.  
5) 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.  

답 : 4) 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 
        다형성을 프로그램적으로 구현하였다.
```
<br>

**Q2.** A와 B에 들어갈 답은?  

```
서로 상속 관계에 있는 타입 간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 
참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
그래서 참조변수가 가리키는 인스턴스의 실제 타입이 무엇인지 [ A ] 연산자를 사용한다.
어떤 타입에 대한 [ A ] 연산의 결과가 [ B ]라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다. 

답 : A) instanceof  B) true
```

<br>

---
## 《 Chap.31 : 추상 클래스(abstract class) ~ Chap.39 : Object클래스 》

**Q1.** 추상 클래스와 추상 메서드에 대한 설명으로 틀린 것을 모두 고르시오.(2개)
```
2) 추상 클래스에 대한 인스턴스를 생성할 수 없다. 자손 클래스에 의해 미완성 메서드를 구현한 뒤 그 자손클래스에 대한 인스턴스를 생성해야 한다.
5) 자손 클래스는 오버 라이딩을 통해 추상 메서드를 구현한다.
```

<br>

**Q2.** 인터페이스에 대한 설명으로 틀린 것을 모두 고르시오.(2개)
```
3) 인터페이스는 다중 상속이 가능하다. 클래스간에는 단일 상속만이 가능하다.
4) 인터페이스의 추상 메서드 구현 시 클래스를 구현한다는 의미의 'implements'를 사용한다. 클래스의 추상 메서드 구현 시 클래스를 확장한다는 의미의 'extends'를 사용한다.
```
<br>

---
## 《 Chap.40 : 내부 클래스의 제어자와 접근성 ~ Chap.50 : 예제 》

**Q1. Default method의 특징을 쓰시오.**
```
- 추상 메서드와 달리 일반 메서드처럼 몸통{}이 있어야 한다.
- 디폴트 메서드를 사용함으로써, 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
- 접근제어자는 public이며 생략가능하다.
```

<br>

**Q2. Default method가 기존 method와 충돌하는 경우의 규칙 중 틀린 것을 고르시오.**
```
4)
조상 클래스의 메서드가 상속되고, 디폴트 메서드가 무시된다.
```

<br>

**Q3. 다음 내부 클래스의 종류와 특징 중 맞는 것을 모두 고르시오.**
```
1), 3), 8)
2) 인스턴스 클래스는 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적이다.
4) 지역 클래스는 외부 클래스의 메서드 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.
5) 익명 클래스는 클래스의 선언과 객체를 생성을 동시에 한다.
6) 내부 클래스에서는 abstract나 final 제어자를 사용할 수 있다.
7) final과 static이 동시에 붙은 변수는 모든 내부 클래스에서 정의가 가능하다.
9) 지역 클래스는 외부 클래스의 인스턴스 멤버와 스태틱 멤버를 사용할 수 있다.
```
---

## 《 Chap.51 : 익명 클래스 ~ Chap.52 : 예제 》

**Q1.** 다음은 이름이 없는 클래스에 관한 문제이다. O, X를 작성하시오.
```
(1) 지역 클래스에 대한 설명이다 (X)  --> 익명 클래스 
(2) 여러번 사용할 수 있다(X) --> 클래스의 선언과 객체 생성을 동시에 하기 때문에 한 번 사용
(3) 생성자를 가질 수 없다 (O ) --> 이름이 없기 때문에 생성자를 가질 수 없음
(4) 다중 상속이 가능하다 (X) --> 하나의 클래스를 상속받거나, 하나의 인터페이스만 구현할 수 있음
(5) 컴파일 하면 .class 앞에 숫자가 붙는다 (O ) --> ex) Ex7_17$1. class
```
<br>

**Q2.** this , this( ), super, super( ) 의 기능을 각각 설명하시오.
```
this : 멤버 변수와 지역변수의 이름이 같을 때 구분 짓기 위해 사용
this( ) : 같은 클래스의 다른 생성자를 호출하는데 사용
super: 자손 클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용
super( ) : 조상의 생성자를 호출하는데 사용
```